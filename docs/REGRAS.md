# REGRAS — Princípios Fundamentais

Estas regras servem como resumo dos critérios que norteiam o desenvolvimento do BitCrypto.  Elas devem ser respeitadas por todos os colaboradores e automatizadas sempre que possível através dos guard‑rails existentes.

- **Zero dependências externas**: o código deve utilizar apenas C++ padrão, APIs nativas do Windows e CUDA (para o módulo GPU).  Não é permitido linkar bibliotecas como OpenSSL, libsodium ou libs de terceiros.  A compatibilidade alvo é Visual Studio 2022, Windows 11 x64 e CUDA 13.
- **Implementações completas, sem stubs**: evite `TODO`/`FIXME` em rotas principais.  Toda funcionalidade exposta deve estar totalmente implementada e testada.  Se uma funcionalidade ainda não estiver pronta, ela não deve ser exposta publicamente.
- **Const‑time e segurança**: operações envolvendo chaves ou dados sensíveis devem ser independentes do segredo.  Use instruções de troca condicional (`cswap/cmov`) e evite ramos ou acessos de memória dependentes de bits do escalar.  Sempre que possível, preferir representações que permitam adição e subtração constantes (por exemplo, wNAF usa dígitos com sinal)【481458509835048†L575-L593】.
- **Pré‑cálculo com contexto**: otimizações de wNAF e multi‑escalares requerem tabelas de pré‑cálculo.  Essas tabelas devem ser mantidas em um **contexto** explicitamente inicializado e passado às funções.  O contexto não deve ser global para preservar *thread‑safety* e transparência.  Usuários que não fornecem contexto devem receber uma implementação básica (ladder constante) para evitar overhead【411223492370334†L14-L24】.
- **Sem redundância desnecessária**: a duplicação de código é permitida somente para implementar variantes CPU e GPU quando houver ganho comprovado de performance.  Caso contrário, utilize funções e templates compartilhados.
- **Documentação e comentários**: toda lógica complexa deve ser acompanhada de comentários em português, explicando o algoritmo, as invariantes e referências bibliográficas.  A documentação do módulo deve ser mantida em `docs/ARQUITETURA.md` e `docs/COMPLETUDE.md`.
- **Fluxo de construção e entrega**: siga os passos descritos em `MAINTENANCE.md` para rodar guard‑rails, executar testes, atualizar manifestos e empacotar releases.  Ao final de cada ciclo, entregue um pacote ZIP contendo o código, a documentação e os manifestos atualizados.
- **Regras de design para novas funcionalidades**: ao implementar Pippenger, endomorfismo, Shamir's trick, FROST ou BIP‑322, certifique‑se de que as implementações permaneçam alinhadas às regras acima: sem dependências externas, const‑time onde aplicável e reutilização de contextos de pré‑cálculo.  Atualize os guard‑rails com novos tokens que representem essas funcionalidades e adicione testes para garantir cobertura.
